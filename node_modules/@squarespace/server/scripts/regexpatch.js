'use strict';

// regexpatch [options] <filename>
//
// modifies a file given a set of find/replace rules.
//
//     -h, --help               output usage information
//     -o, --output <filename>  Destination file for patch output.
//                              Default is to overwrite file.
//     -p, --param [pair]       A name=value pair that will be used while patching.
//                              Several -p options can be added.
//     -c, --config <filename>  Json config file of the form
//                              {"rules":[["regex", "replace"]...]}. The replace
//                              string will be rendered as an underscore template,
//                              using params as context, before being evaluated.
//                              Both underscore ${context} variables and $1 regex
//                              groups are valid.
//
// Example:
//
//   patch.json:
//     {
//       "rules": [
//         ["^cats$", "${animals}"]
//       ]
//     }
//
//   command line:
//     > regex-patch -p animals=dogs -c patch.json -o output.txt input.txt


var fs = require('fs');
var path = require('path');
var program = require('commander');
var _ = require('lodash');

function patchFile(inName, outName, ctx, config) {
  console.log('Patching ' + inName);
  var content = fs.readFileSync(inName, 'utf8');
  for (var r = 0; r < config.rules.length; r++) {
    var rule = config.rules[r];
    if (rule.length < 2) {
      console.error('Invalid rule: ', rule);
      continue;
    }
    var replacement = _.template(rule[1])(ctx);
    content = content.replace(new RegExp(rule[0], "m"), replacement);
  }
  fs.writeFileSync(outName, content);
}


function matchPermissions(inFile, outFile) {
  var mode = fs.statSync(inFile).mode;
  fs.chmodSync(outFile, mode);
}

function getContext(params) {
  var context = {};
  for (var p = 0; p < params.length; p++) {
    if (params[p].length > 1) {
      context[params[p][0]] = params[p][1];
    }
  }
  return context;
}

function getConfig(configFile) {
  return JSON.parse(fs.readFileSync(configFile, 'utf8'));
}

function main(options, filename) {
  var context = getContext(options.param);
  var output = options.output || filename;
  var config = options.config ? getConfig(options.config) : {};
  patchFile(filename, output, context, config);
  if (output.toLowerCase() !== filename.toLowerCase()) {
    matchPermissions(filename, output);
  }
}

var fileNameArg;
program
  .usage('[options] <filename>')
  .arguments('<filename>')
  .action(function(filename) {
    if (!filename) {
      console.error('Missing filename.');
      process.exit(1);
    }
    fileNameArg = filename;
  })
  .option('-o, --output <filename>', 'Destination file for patch output. Default is to overwrite file.')
  .option('-p, --param [pair]',
    'A name=value pair that will be used while patching. Several -p options can be added.',
    function(val, memo) { memo.push(val.split('=')); return memo },
    [])
  .option('-c, --config <filename>', 'Json config file of the form {"rules":[["regex", "replace"]...]}. ' +
    'The replace string will be rendered as an underscore template, using params as context, before ' +
    'being evaluated. Both underscore ${context} variables and $1 regex groups are valid.')
  .parse(process.argv);

main(program, fileNameArg);
